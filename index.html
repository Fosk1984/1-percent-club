<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>1% Club ‚Äî Multiplayer (Firebase)</title>
  <meta name="description" content="Host-controlled 1% Club style quiz with up to 80 players. Built for GitHub Pages + Firebase Realtime Database.">
  <link rel="icon" href="data:,">
  <style>
    :root{
      --bg:#0b0f1a; --card:#12172a; --ink:#eaf0ff; --muted:#9aa4bf; --edge:#22315c;
      --acc:#6ac2ff; --acc2:#ffd36a; --ok:#33d17a; --bad:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--ink); background:radial-gradient(1200px 800px at 15% -10%, #182449 0%, #0f1730 40%, var(--bg) 100%);
    }
    .shell{max-width:1100px; margin:0 auto; padding:24px}
    h1{margin:0 0 12px; font-size:clamp(22px,3.2vw,36px)}
    h2{margin:18px 0 8px; font-size:clamp(18px,2.2vw,24px)}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.08)); border:1px solid var(--edge);
      box-shadow:0 10px 30px rgba(0,0,0,.35); border-radius:16px; padding:16px; margin:12px 0}
    .grid{display:grid; gap:12px}
    .g2{grid-template-columns:repeat(2,minmax(0,1fr))}
    .g3{grid-template-columns:repeat(3,minmax(0,1fr))}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    label{font-size:14px; color:var(--muted)}
    input, textarea, select{width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--edge);
      background:#0f1530; color:var(--ink)}
    textarea{min-height:100px; resize:vertical}
    button{cursor:pointer; border:1px solid var(--edge); background:linear-gradient(180deg,#1a254d,#121a38);
      color:var(--ink); padding:10px 14px; border-radius:12px; font-weight:600; box-shadow:0 6px 16px rgba(0,0,0,.35)}
    button[disabled]{opacity:.5; cursor:not-allowed}
    .btn-acc{background:linear-gradient(180deg,#3aa7ff,#2263a2)}
    .btn-acc2{background:linear-gradient(180deg,#ffd36a,#c49e2e); color:#1a1400}
    .btn-ok{background:linear-gradient(180deg,#33d17a,#1a7a49)}
    .btn-bad{background:linear-gradient(180deg,#ff6b6b,#b13a3a)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .hint{color:var(--muted); font-size:13px}
    .pill{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
      background:#0d1430; border:1px solid var(--edge); font-size:13px}
    .timer{font-variant-numeric:tabular-nums; font-size:22px}
    .answers{display:grid; gap:10px; grid-template-columns:1fr}
    .answerBtn{padding:16px; text-align:left; border-radius:14px; border:1px solid var(--edge); background:#101a3a;
      font-size:16px}
    .answerBtn.selected{outline:2px solid var(--acc)}
    .answerBtn.correct{outline:2px solid var(--ok)}
    .answerBtn.wrong{outline:2px solid var(--bad)}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .list{max-height:260px; overflow:auto; padding-right:6px}
    .tag{padding:.2rem .45rem; border-radius:8px; border:1px solid var(--edge); background:#0c1230; font-size:12px}
    .center{display:flex; align-items:center; justify-content:center}
    .big{font-size:clamp(28px,4vw,44px); font-weight:700}
    .hide{display:none !important}

    /* Percent Ladder */
    .percent-ladder{--card:#12172a;--ink:#eaf0ff;--muted:#9aa4bf;--acc:#6ac2ff;--ok:#33d17a;--chk:#ffd36a;
      display:flex;flex-direction:column;gap:.35rem;background:var(--card);padding:.75rem;border-radius:.75rem;border:1px solid #22305f;}
    .percent-ladder .hdr{color:var(--muted);font:600 12px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;letter-spacing:.04em;text-transform:uppercase;margin-bottom:.25rem}
    .pl-steps{display:flex;flex-direction:column-reverse;gap:.25rem}
    .pl-step{display:flex;align-items:center;gap:.5rem;padding:.45rem .6rem;border-radius:.5rem;border:1px solid #24336a;
      color:var(--ink);background:linear-gradient(180deg,#151c36,#12172a);cursor:pointer;position:relative;user-select:none;outline:none}
    .pl-step[data-cleared="true"]{background:linear-gradient(180deg,#122a1c,#0f1f18);border-color:#1f5137}
    .pl-step[data-cleared="true"] .tag{color:var(--ok)}
    .pl-step[data-current="true"]{box-shadow:0 0 0 2px var(--acc) inset, 0 8px 30px rgba(106,194,255,.25)}
    .pl-step[data-checkpoint="true"]::after{content:"";position:absolute;right:10px;top:50%;transform:translateY(-50%);width:.55rem;height:.55rem;border-radius:50%;background:var(--acc2);box-shadow:0 0 8px rgba(255,211,106,.8)}
    .pct{font:600 14px/1 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .tag{margin-left:auto;font:500 11px/1 ui-sans-serif,system-ui;letter-spacing:.03em;color:var(--muted)}
  </style>
</head>
<body>
  <div class="shell">
    <h1>üß† The 1% Club ‚Äî Multiplayer</h1>
    <div id="landing" class="card">
      <div class="row">
        <label class="pill"><input type="checkbox" id="isHostToggle">I'm the host</label>
        <span class="hint">GitHub Pages + Firebase (Anonymous sign-in). Room code sharing built-in.</span>
      </div>
      <div id="hostLanding" class="grid g2" style="margin-top:8px;">
        <div class="card">
          <h2>Host: create a room</h2>
          <div class="grid g2">
            <div>
              <label>Room code (optional)</label>
              <input id="hostRoomCode" maxlength="6" placeholder="e.g. 7H2K9Q" />
            </div>
            <div>
              <label>Player limit</label>
              <input id="playerLimit" type="number" min="2" max="80" value="80" />
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <button id="createRoomBtn" class="btn-acc">Create room</button>
            <span class="hint">You‚Äôll join as host (not a contestant).</span>
          </div>
        </div>
        <div class="card">
          <h2>Players: join a room</h2>
          <div class="grid g2">
            <div>
              <label>Room code</label>
              <input id="joinCode" maxlength="6" placeholder="Enter code" />
            </div>
            <div>
              <label>Your display name</label>
              <input id="displayName" maxlength="24" placeholder="e.g. Alex" />
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <button id="joinBtn" class="btn-ok">Join game</button>
            <span class="hint">Up to 80 players. Eliminated on wrong answer.</span>
          </div>
        </div>
      </div>
    </div>

    <div id="hostUI" class="card hide">
      <div class="row">
        <div class="pill">Room: <span id="roomCodeHost" class="mono"></span></div>
        <div class="pill">Players alive: <span id="aliveCount">0</span></div>
        <div class="pill">Question #<span id="qNumber">0</span></div>
        <button id="copyInvite" class="">Copy invite</button>
        <label class="pill"><input type="checkbox" id="muteSounds">Mute sounds</label>
      </div>

      <div class="grid g2" style="margin-top:10px">
        <div class="card">
          <h2>Question builder</h2>
          <label>Question prompt</label>
          <textarea id="qPrompt" placeholder="e.g. What is 15% of 220?"></textarea>
          <div class="grid g2">
            <div><label>A</label><input id="opt0" placeholder="e.g. 33"/></div>
            <div><label>B</label><input id="opt1" placeholder="e.g. 30"/></div>
            <div><label>C</label><input id="opt2" placeholder="e.g. 22"/></div>
            <div><label>D</label><input id="opt3" placeholder="e.g. 28"/></div>
          </div>
          <div class="grid g2">
            <div>
              <label>Correct answer</label>
              <select id="correctIndex">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
                <option value="3">D</option>
              </select>
            </div>
            <div>
              <label>Answer window</label>
              <select id="answerWindow">
                <option value="30">30 seconds</option>
                <option value="20">20 seconds</option>
                <option value="15">15 seconds</option>
                <option value="10">10 seconds</option>
              </select>
            </div>
          </div>
          <label>Explanation (optional, shown after scoring)</label>
          <textarea id="qExplanation" placeholder="Brief rationale or reference‚Ä¶"></textarea>

          <div class="row" style="margin-top:10px">
            <button id="stageHiddenBtn" title="(1) Arm hidden">1) Arm</button>
            <button id="revealBtn" class="btn-acc" title="(R)">2) Reveal & start</button>
            <button id="lockBtn" class="btn-bad" title="(L)">3) Lock</button>
            <button id="scoreBtn" class="btn-ok" title="(S)">4) Reveal correct</button>
            <button id="nextBtn" class="btn-acc2" title="(N)">Next</button>
          </div>
          <div class="hint">Hotkeys: R=reveal, L=lock, S=score, N=next.</div>
        </div>

        <div class="card">
          <h2>Players</h2>
          <div id="playersList" class="list"></div>
        </div>
      </div>

      <div class="grid g2">
        <div class="card">
          <h2>Live question</h2>
          <div class="row">
            <div class="pill">Phase: <span id="phaseTxt">‚Äî</span></div>
            <div class="pill">Deadline: <span id="deadlineTxt" class="timer">‚Äî</span></div>
            <div class="pill">Percent: <span id="percentTxt">‚Äî</span></div>
          </div>
          <div id="livePrompt" class="big" style="margin-top:8px">‚Äî</div>
          <div id="liveChoices" class="grid g2" style="margin-top:8px"></div>
          <div id="hostResults" style="margin-top:10px"></div>
          <div id="hostExplanation" class="muted" style="margin-top:8px"></div>
        </div>

        <div class="card">
          <h2>Percent Ladder</h2>
          <div id="ladder" class="percent-ladder" role="group" aria-label="Percent ladder">
            <div class="hdr">This 10‚ÄëQ chunk</div>
            <div class="pl-steps" aria-live="polite"></div>
          </div>
          <div class="hint small" style="margin-top:8px">
            Uses <code>percent</code> from your bank (if present). Otherwise maps chunk index to [90,80,‚Ä¶,1].
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Question bank</h2>
        <div class="row" style="margin-bottom:8px">
          <span class="pill">Loaded: <span id="bankCount">0</span></span>
          <span class="pill">Next: <span id="bankNext">1</span></span>
        </div>
        <textarea id="bankText" placeholder='Paste JSON or CSV with columns: prompt,A,B,C,D,correct,seconds,percent,explanation'></textarea>
        <div class="row" style="margin-top:10px">
          <button id="importBankBtn">Import JSON/CSV</button>
          <button id="stageNextBtn" class="btn-acc2">Stage next from bank</button>
          <button id="exportBtn">Export results (CSV)</button>
        </div>
        <div class="hint small">JSON example: {"prompt":"‚Ä¶","options":["A","B","C","D"],"correctIndex":1,"seconds":20,"percent":80,"explanation":"‚Ä¶"}.</div>
      </div>
    </div>

    <div id="playerUI" class="card hide">
      <div class="row">
        <div class="pill">Room: <span id="roomCodePlayer" class="mono"></span></div>
        <div class="pill">Name: <span id="meName" class="mono"></span></div>
        <div class="pill">Status: <span id="statusTxt">Waiting‚Ä¶</span></div>
        <div class="pill">Time left: <span id="timeLeft" class="timer">‚Äî</span></div>
      </div>

      <!-- QR join (for spectators to scan) -->
      <div class="card">
        <h2>Invite QR</h2>
        <div class="row">
          <img id="qrImg" alt="Join QR" style="width:140px; height:140px; border-radius:8px; border:1px solid var(--edge); background:#0c1230"/>
          <div class="muted small">Scan to join this room on another device.</div>
        </div>
      </div>

      <div id="msg" class="muted" style="margin-top:6px">Waiting for host‚Ä¶</div>
      <div id="qArea" class="hide">
        <div id="pPrompt" class="big" style="margin:10px 0">‚Äî</div>
        <div class="muted" id="pPercent" style="margin:-6px 0 8px"> </div>
        <div class="answers" id="answerBtns"></div>
        <div id="resultsPlayer" style="margin-top:10px"></div>
        <div id="playerExplanation" class="muted" style="margin-top:8px"></div>
      </div>
      <div id="eliminated" class="hide center" style="height:160px"><div class="big">‚ùå You‚Äôve been eliminated</div></div>

      <div class="card" style="margin-top:10px">
        <h2>Players</h2>
        <div id="playersListPlayer" class="list"></div>
      </div>
    </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js';
    import { getAuth, onAuthStateChanged, signInAnonymously } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js';
    import { getDatabase, ref, child, get, set, update, onValue, onDisconnect } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js';

    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAAlHBdemzktDB25HozuliuL6BWcYZ7hUg",
      authDomain: "percent-club-76c05.firebaseapp.com",
      databaseURL: "https://percent-club-76c05-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "percent-club-76c05",
      storageBucket: "percent-club-76c05.appspot.com",
      messagingSenderId: "87140817040",
      appId: "1:87140817040:web:aee1db0e278e641f97a015",
      measurementId: "G-8V0MWEYWLZ"
    };

    // --- App state ---
    const app = initializeApp(FIREBASE_CONFIG);
    const auth = getAuth(app);
    const db = getDatabase(app);

    // Server time offset for deadlines
    let serverOffset = 0;
    onValue(ref(db, '.info/serverTimeOffset'), (snap)=> { serverOffset = snap.val() || 0; });

    const els = (q)=>document.querySelector(q);
    const $$ = (q)=>Array.from(document.querySelectorAll(q));

    // Sounds
    const ding = new Audio('data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA...');
    const buzz = new Audio('data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA...'); // tiny silent placeholders; replace with real data URIs if you like
    const playSound = (a)=>{ const muted = els('#muteSounds')?.checked; if (!muted) { try{ a.currentTime=0; a.play(); }catch{} } };

    // Codes
    const codeChars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    const genCode = (len=6)=>Array.from({length:len},()=>codeChars[Math.floor(Math.random()*codeChars.length)]).join('');

    // progressAbs drives ladder; bankIndex is staging cursor
    const state = {
      uid:null, room:null, host:false, me:null,
      current:null, timerInt:null,
      bank:[], bankIndex:0,
      meEliminated:false,
      progressAbs:0,
      stagedPercent: undefined,
      stagedIndex: undefined
    };

    // Host UI refs
    const hostUI = els('#hostUI'), playerUI = els('#playerUI'), landing = els('#landing');
    const isHostToggle = els('#isHostToggle'), hostLanding = els('#hostLanding');
    const hostRoomCode = els('#hostRoomCode'), playerLimitEl = els('#playerLimit'), createRoomBtn = els('#createRoomBtn');
    const joinCode = els('#joinCode'), displayName = els('#displayName'), joinBtn = els('#joinBtn');
    const roomCodeHost = els('#roomCodeHost'), aliveCount = els('#aliveCount'), qNumber = els('#qNumber'), copyInvite = els('#copyInvite');
    const playersList = els('#playersList'), phaseTxt = els('#phaseTxt'), deadlineTxt = els('#deadlineTxt'), livePrompt = els('#livePrompt');
    const liveChoices = els('#liveChoices'), hostResults = els('#hostResults'), percentTxt = els('#percentTxt'), hostExplanation = els('#hostExplanation');
    const qPrompt = els('#qPrompt'), opt0 = els('#opt0'), opt1 = els('#opt1'), opt2 = els('#opt2'), opt3 = els('#opt3');
    const qExplanation = els('#qExplanation');
    const correctIndex = els('#correctIndex'), answerWindow = els('#answerWindow');
    const stageHiddenBtn = els('#stageHiddenBtn'), revealBtn = els('#revealBtn'), lockBtn = els('#lockBtn'), scoreBtn = els('#scoreBtn'), nextBtn = els('#nextBtn');
    const bankText = els('#bankText'), importBankBtn = els('#importBankBtn'), stageNextBtn = els('#stageNextBtn'), bankCount = els('#bankCount'), bankNext = els('#bankNext');
    const exportBtn = els('#exportBtn');

    // Player UI refs
    const roomCodePlayer = els('#roomCodePlayer'), meName = els('#meName'), statusTxt = els('#statusTxt'), timeLeft = els('#timeLeft');
    const msg = els('#msg'), qArea = els('#qArea'), pPrompt = els('#pPrompt'), answerBtns = els('#answerBtns'), resultsPlayer = els('#resultsPlayer');
    const eliminated = els('#eliminated'), playersListPlayer = els('#playersListPlayer'), pPercent = els('#pPercent'), playerExplanation = els('#playerExplanation');
    const qrImg = els('#qrImg');

    // ===== Percent Ladder =====
    class PercentLadder {
      constructor(selectorOrEl, {steps=[], currentIndex=0, cleared=[], checkpoints=[]}={}){
        this.el = typeof selectorOrEl==='string' ? document.querySelector(selectorOrEl) : selectorOrEl;
        this.steps = steps.slice(); this.currentIndex = currentIndex|0;
        this.cleared = new Set(cleared||[]); this.checkpoints = new Set(checkpoints||[]);
        this._stepsRoot = this.el.querySelector('.pl-steps'); this.render(); this._attach();
      }
      _attach(){
        this._stepsRoot.addEventListener('click', (e)=>{
          const item = e.target.closest('.pl-step'); if(!item) return;
          const idx = +item.dataset.index; this.setCurrent(idx);
          this.el.dispatchEvent(new CustomEvent('ladder-select',{detail:{index:idx, percent:this.steps[idx]}}));
        });
      }
      render(){
        const frag = document.createDocumentFragment(); this._stepsRoot.innerHTML='';
        this.steps.forEach((pct, idx)=>{
          const step = document.createElement('button');
          step.type='button'; step.className='pl-step';
          step.dataset.index=idx;
          step.dataset.current = (idx===this.currentIndex);
          step.dataset.cleared = this.cleared.has(idx);
          step.dataset.checkpoint = this.checkpoints.has(idx);
          step.setAttribute('aria-pressed', idx===this.currentIndex ? 'true':'false');
          step.setAttribute('aria-label', `${pct}% step`);
          step.innerHTML = `<span class="pct">${pct}%</span><span class="tag">${idx===this.currentIndex?'Current':(this.cleared.has(idx)?'Cleared':'')}</span>`;
          frag.appendChild(step);
        });
        this._stepsRoot.appendChild(frag);
      }
      setSteps(steps){ this.steps = steps.slice(); this.currentIndex = Math.min(this.currentIndex, this.steps.length-1); this.render(); }
      setCurrent(i){
        this.currentIndex = i;
        [...this._stepsRoot.children].forEach(btn=>{
          const isCur = +btn.dataset.index===i;
          btn.dataset.current = isCur; btn.setAttribute('aria-pressed', isCur ? 'true':'false');
          btn.querySelector('.tag').textContent = isCur ? 'Current' : (btn.dataset.cleared==='true' ? 'Cleared' : '');
        });
      }
      setCleared(indices){
        this.cleared = new Set(indices||[]);
        [...this._stepsRoot.children].forEach(btn=>{
          const isCleared = this.cleared.has(+btn.dataset.index);
          btn.dataset.cleared = isCleared;
          if(!isCleared && btn.dataset.current!=='true') btn.querySelector('.tag').textContent='';
          if(isCleared && btn.dataset.current!=='true') btn.querySelector('.tag').textContent='Cleared';
        });
      }
      setCheckpoints(indices){
        this.checkpoints = new Set(indices||[]);
        [...this._stepsRoot.children].forEach(btn=>{ btn.dataset.checkpoint = this.checkpoints.has(+btn.dataset.index); });
      }
    }
    const ladder = new PercentLadder('#ladder', { steps:[90,80,70,60,50,40,30,20,10,1], currentIndex:0, cleared:[], checkpoints:[4,7] });

    const defPerc = [90,80,70,60,50,40,30,20,10,1];
    const percentForAbsoluteIndex = (abs)=>{
      const start = Math.floor(abs/10)*10;
      const item = state.bank[abs];
      if (item && Number.isFinite(item.percent)) return item.percent;
      return defPerc[abs - start] ?? 90;
    };
    const chunkStart = (abs)=>Math.floor(abs/10)*10;
    const buildSteps = (start)=>{
      const steps = defPerc.slice();
      for(let k=0;k<10;k++){
        const it = state.bank[start+k];
        if (it && Number.isFinite(it.percent)) steps[k] = it.percent;
      }
      return steps;
    };
    const syncLadderToProgress = ()=>{
      const start = chunkStart(state.progressAbs);
      const steps = buildSteps(start);
      const within = state.progressAbs % 10;
      ladder.setSteps(steps);
      ladder.setCleared(Array.from({length: within}, (_,i)=>i));
      ladder.setCurrent(within);
    };
    document.getElementById('ladder').addEventListener('ladder-select', (e)=>{
      const start = chunkStart(state.progressAbs);
      state.progressAbs = start + e.detail.index; syncLadderToProgress();
    });

    // ===== Auth =====
    createRoomBtn.disabled = true; joinBtn.disabled = true;
    onAuthStateChanged(auth, async (user)=>{
      if(user){ state.uid = user.uid; createRoomBtn.disabled = false; joinBtn.disabled = false; return; }
      await signInAnonymously(auth);
    });
    isHostToggle.addEventListener('change', ()=>{ state.host = isHostToggle.checked; hostLanding.classList.toggle('hide', !state.host); });

    // Create room
    createRoomBtn.addEventListener('click', async ()=>{
      const code = (hostRoomCode.value || genCode()).toUpperCase();
      const limit = Math.min(80, Math.max(2, parseInt(playerLimitEl.value||"80",10)));
      const roomRef = ref(db, `rooms/${code}`);
      await set(child(roomRef,'meta'), { hostUid: state.uid, allowJoin: true, playerLimit: limit, qIndex: 0, createdAt: Date.now() + serverOffset });
      await set(child(roomRef,'current'), { phase:'hidden', qid:0 });
      state.room = code; state.host = true; enterHost();
    });

    // Join room
    joinBtn.addEventListener('click', async ()=>{
      const code = (joinCode.value||'').toUpperCase().trim();
      const name = (displayName.value||'Player').trim();
      if(!code) return alert('Enter room code');
      const roomRef = ref(db, `rooms/${code}`);
      const snap = await get(child(roomRef,'meta'));
      if(!snap.exists()) return alert('Room not found');
      const meta = snap.val();
      if(!meta.allowJoin) return alert('Host has closed joining');

      const playersSnap = await get(child(roomRef,'players'));
      const count = playersSnap.exists()? Object.values(playersSnap.val()).filter(p=>p.present && !p.eliminated).length : 0;
      if(count >= (meta.playerLimit||80)) return alert('Room is full');

      await update(child(roomRef,`players/${state.uid}`), { name, present:true, eliminated:false, joinedAt: Date.now() + serverOffset });
      const meRef = child(roomRef,`players/${state.uid}/present`); onDisconnect(meRef).set(false);

      state.room = code; state.host = false; state.me = {name}; enterPlayer();
    });

    function enterHost(){
      landing.classList.add('hide'); hostUI.classList.remove('hide');
      roomCodeHost.textContent = state.room; wireRoomListeners(); syncLadderToProgress();
      // Hotkeys
      window.addEventListener('keydown', (e)=>{
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        const k = e.key.toLowerCase();
        if (k==='r') revealBtn.click();
        else if (k==='l') lockBtn.click();
        else if (k==='s') scoreBtn.click();
        else if (k==='n') nextBtn.click();
      });
    }
    function enterPlayer(){
      landing.classList.add('hide'); playerUI.classList.remove('hide');
      roomCodePlayer.textContent = state.room; meName.textContent = state.me?.name || '';
      // QR join for spectators / sharing
      const url = `${location.origin}${location.pathname}?room=${state.room}`;
      qrImg.src = `https://chart.googleapis.com/chart?cht=qr&chs=180x180&chl=${encodeURIComponent(url)}`;
      wireRoomListeners();
    }

    async function ensureArmedQuestion(db, roomCode){
      const metaRef = ref(db, `rooms/${roomCode}/meta`);
      const curRef  = ref(db, `rooms/${roomCode}/current`);
      const [metaSnap, curSnap] = await Promise.all([get(metaRef), get(curRef)]);
      const meta = metaSnap.val() || {};
      const cur  = curSnap.val() || {};
      if (cur.qid && Number.isInteger(cur.qid) && cur.qid > 0) return cur.qid;
      const qid = (meta.qIndex || 0) + 1;
      await update(metaRef, { qIndex: qid });
      await set(curRef, { phase:'hidden', qid, prompt:null, choices:null, stats:null });
      return qid;
    }

    // Arm hidden
    stageHiddenBtn.addEventListener('click', async ()=>{
      const code = state.room; if(!code) return;
      const metaRef = ref(db, `rooms/${code}/meta`);
      const metaSnap = await get(metaRef); const meta = metaSnap.val()||{};
      const qid = (meta.qIndex||0)+1;
      await update(metaRef, { qIndex: qid });
      await set(ref(db,`rooms/${code}/current`), { phase:'hidden', qid, prompt:null, choices:null, stats:null });
      qNumber.textContent = qid; phaseTxt.textContent = 'hidden';
    });

    // Reveal
    revealBtn.addEventListener('click', async ()=>{
      try{
        if(!qPrompt.value.trim()) return alert('Enter a question');
        const choices = [opt0.value, opt1.value, opt2.value, opt3.value];
        if(choices.some(c=>!c || !c.trim())) return alert('Enter all 4 choices');

        const secs = parseInt(answerWindow.value,10);
        const code = state.room;
        const qid  = await ensureArmedQuestion(db, code);

        const currentRef = ref(db,`rooms/${code}/current`);
        const nowMs     = Date.now() + serverOffset;
        const deadline  = nowMs + secs*1000;

        let absIndexForThisReveal = (typeof state.stagedIndex === 'number') ? state.stagedIndex : state.progressAbs;
        const p = (typeof state.stagedPercent === 'number') ? state.stagedPercent : percentForAbsoluteIndex(absIndexForThisReveal);

        const payload = {
          phase: 'revealed',
          qid,
          prompt: qPrompt.value.trim(),
          choices,
          deadline,
          percent: p,
          explanation: qExplanation.value?.trim() || null
        };

        await set(currentRef, payload);
        state.progressAbs = Math.min(absIndexForThisReveal + 1, Math.max(0, state.bank.length));
        syncLadderToProgress();
      }catch(err){
        console.error('[reveal] failed:', err);
        alert('Reveal failed: ' + (err?.message || err));
      }
    });

    // Lock
    lockBtn.addEventListener('click', async ()=>{
      const code = state.room; const currentRef = ref(db,`rooms/${code}/current`);
      await update(currentRef, { phase:'locked', deadline: Date.now() + serverOffset });
    });

    // Score
    scoreBtn.addEventListener('click', async () => {
      const code = state.room;
      const currentRef = ref(db, `rooms/${code}/current`);
      const curSnap = await get(currentRef);
      const cur = curSnap.val();
      if (!cur || cur.phase === 'hidden') { alert('Reveal first'); return; }

      const cIdx = parseInt(correctIndex.value, 10);
      await update(currentRef, { phase: 'result', correctIndex: cIdx });

      const [ansSnap, playersSnap] = await Promise.all([
        get(ref(db, `rooms/${code}/answers/${cur.qid}`)),
        get(ref(db, `rooms/${code}/players`))
      ]);

      const answers = ansSnap.exists() ? ansSnap.val() : {};
      const players = playersSnap.exists() ? playersSnap.val() : {};

      const updates = {};
      for (const [uid, p] of Object.entries(players)) {
        if (!(p.present && !p.eliminated)) continue;
        const a = answers[uid];
        const wrongOrMissing = !a || a.index !== cIdx;
        if (wrongOrMissing) updates[`rooms/${code}/players/${uid}/eliminated`] = true;
      }
      if (Object.keys(updates).length) await update(ref(db), updates);

      const counts = [0,0,0,0]; let total = 0;
      for (const a of Object.values(answers)) {
        if (a && Number.isInteger(a.index) && a.index >= 0 && a.index <= 3) { counts[a.index]++; total++; }
      }
      await update(currentRef, { stats: { counts: { 0: counts[0], 1: counts[1], 2: counts[2], 3: counts[3] }, total } });

      playSound(ding); // positive sfx on reveal result
    });

    // Next
    nextBtn.addEventListener('click', async () => {
      const code = state.room;
      const metaSnap = await get(ref(db, `rooms/${code}/meta`));
      const meta = metaSnap.val() || {};
      const qid = (meta.qIndex || 0) + 1;

      await update(ref(db, `rooms/${code}/meta`), { qIndex: qid });
      await set(ref(db, `rooms/${code}/current`), { phase: 'hidden', qid, prompt: null, choices: null, stats: null });

      qPrompt.value = opt0.value = opt1.value = opt2.value = opt3.value = qExplanation.value = '';
      correctIndex.value = '0';
      state.stagedPercent = undefined;
      state.stagedIndex = undefined;
    });

    // Copy invite
    copyInvite.addEventListener('click', async ()=>{
      const url = `${location.origin}${location.pathname}?room=${state.room}`;
      await navigator.clipboard.writeText(`Join my 1% Club game: ${url} (code ${state.room})`);
      copyInvite.textContent = 'Copied!'; setTimeout(()=>copyInvite.textContent='Copy invite',1500);
    });

    // Roster admin buttons (host)
    function makeHostPlayerRow(uid, p){
      const row = document.createElement('div'); row.className='row';
      const name = document.createElement('div'); name.textContent = p.name||'Player';
      const tags = document.createElement('div'); tags.className='row';
      tags.innerHTML = `<span class="tag">${p.present? 'present':'offline'}</span> <span class="tag">${p.eliminated? '‚ùå out':'‚úÖ in'}</span>`;
      const revive = document.createElement('button'); revive.textContent='Revive'; revive.disabled = !p.eliminated;
      revive.addEventListener('click', async ()=>{ await update(ref(db, `rooms/${state.room}/players/${uid}`), { eliminated:false }); playSound(ding); });
      const kick = document.createElement('button'); kick.textContent='Kick';
      kick.addEventListener('click', async ()=>{ await update(ref(db, `rooms/${state.room}/players/${uid}`), { present:false, eliminated:true }); playSound(buzz); });
      row.appendChild(name); row.appendChild(tags); row.appendChild(revive); row.appendChild(kick);
      return row;
    }

    // Listeners
    function wireRoomListeners(){
      const code = state.room; if(!code) return;

      onValue(ref(db,`rooms/${code}/meta`), (snap)=>{ const meta = snap.val()||{}; qNumber.textContent = meta.qIndex||0; });

      onValue(ref(db,`rooms/${code}/current`), (snap)=>{
        state.current = snap.val()||{}; const cur = state.current;
        percentTxt.textContent = (cur && typeof cur.percent === 'number') ? `${cur.percent}%` : '‚Äî';
        pPercent.textContent = (cur && typeof cur.percent === 'number') ? `This question: ${cur.percent}%` : '';
        hostExplanation.textContent = (cur && cur.phase==='result' && cur.explanation) ? `Explanation: ${cur.explanation}` : '';
        playerExplanation.textContent = (cur && cur.phase==='result' && cur.explanation) ? `Explanation: ${cur.explanation}` : '';

        phaseTxt.textContent = cur.phase || '‚Äî';
        deadlineTxt.textContent = cur.deadline? new Date(cur.deadline).toLocaleTimeString(): '‚Äî';
        livePrompt.textContent = cur.prompt || '‚Äî';
        liveChoices.innerHTML = '';
        if (cur.choices){
          cur.choices.forEach((c,i)=>{ const div = document.createElement('div'); div.className='tag'; div.textContent = ['A','B','C','D'][i]+': '+c; liveChoices.appendChild(div); });
        }

        if (state.host){
          const counts = cur.stats && cur.stats.counts ? [cur.stats.counts[0]||0,cur.stats.counts[1]||0,cur.stats.counts[2]||0,cur.stats.counts[3]||0] : null;
          renderResults(hostResults, counts, cur.stats?.total||0, cur.correctIndex);
        }

        if (!state.host){
          statusTxt.textContent = state.meEliminated ? 'spectating' : (cur.phase || '‚Äî');
          if (cur.phase === 'revealed' || cur.phase === 'locked' || cur.phase === 'result'){
            msg.classList.add('hide'); qArea.classList.remove('hide'); pPrompt.textContent = cur.prompt || '‚Äî'; renderAnswerButtons(cur);
            if (cur.phase === 'revealed') startTimer(cur.deadline); else stopTimer();
            const countsP = cur.stats && cur.stats.counts ? [cur.stats.counts[0]||0,cur.stats.counts[1]||0,cur.stats.counts[2]||0,cur.stats.counts[3]||0] : null;
            if (cur.phase === 'result') { renderResults(resultsPlayer, countsP, cur.stats?.total||0, cur.correctIndex); revealCorrect(cur); } else { resultsPlayer.innerHTML = ''; }
          } else { msg.classList.remove('hide'); qArea.classList.add('hide'); resultsPlayer.innerHTML = ''; }
        }
      });

      onValue(ref(db,`rooms/${code}/players`), (snap)=>{
        const players = snap.val()||{}; const entries = Object.entries(players);
        const alive = entries.filter(([,p])=>p.present && !p.eliminated).length; aliveCount.textContent = alive;

        if (state.host){
          const sorted = entries.sort(([,a],[,b])=>{
            const rank = (p)=> (p.present?1:0) + (p.eliminated?0:2); return rank(b) - rank(a);
          });
          playersList.innerHTML = '';
          sorted.forEach(([uid,p])=>{ playersList.appendChild(makeHostPlayerRow(uid,p)); });
        } else {
          const me = players[state.uid]||{}; state.meEliminated = !!me.eliminated; eliminated.classList.toggle('hide', !state.meEliminated);
          const sorted = entries.sort(([,a],[,b])=>{
            const rank = (p)=> (p.present?1:0) + (p.eliminated?0:2); return rank(b) - rank(a);
          });
          playersListPlayer.innerHTML = '';
          sorted.forEach(([,p])=>{
            const row = document.createElement('div'); row.className='row';
            const name = document.createElement('div'); name.textContent = p.name||'Player';
            const tags = document.createElement('div'); tags.className='row';
            tags.innerHTML = `<span class="tag">${p.present? 'present':'offline'}</span> <span class="tag">${p.eliminated? '‚ùå out':'‚úÖ in'}</span>`;
            row.appendChild(name); row.appendChild(tags); playersListPlayer.appendChild(row);
          });
        }
      });
    }

    function renderAnswerButtons(cur){
      answerBtns.innerHTML = '';
      const canAnswer = cur.phase === 'revealed' && !state.meEliminated;
      ['A','B','C','D'].forEach((letter,i)=>{
        const btn = document.createElement('button'); btn.className='answerBtn';
        btn.textContent = `${letter}. ${cur.choices?.[i]||''}`;
        btn.disabled = !canAnswer;
        if (canAnswer) btn.addEventListener('click', ()=> submitAnswer(i));
        answerBtns.appendChild(btn);
      });
    }

    async function submitAnswer(index){
      const code = state.room; const cur = state.current;
      if (!cur || cur.phase!=='revealed') return;
      const nowMs = Date.now() + serverOffset;
      if (typeof cur.deadline === 'number' && nowMs > cur.deadline) { alert('Too late ‚Äî time‚Äôs up!'); return; }
      const uid = auth.currentUser?.uid || state.uid;
      if (!uid){ alert('Auth not ready yet. Please rejoin.'); return; }
      const ansRef = ref(db,`rooms/${code}/answers/${cur.qid}/${uid}`);
      try{
        await set(ansRef, { index, at: nowMs });
        $$('.answerBtn').forEach((b,bi)=> { b.classList.toggle('selected', bi===index); b.disabled = true; });
      }catch(err){
        alert('Answer not accepted ‚Äî timer likely expired.'); console.error(err);
      }
    }

    function revealCorrect(cur){
      if (cur.correctIndex == null) return;
      $$('.answerBtn').forEach((b,bi)=>{ b.classList.toggle('correct', bi===cur.correctIndex); b.classList.toggle('wrong', bi!==cur.correctIndex); b.disabled = true; });
    }

    function startTimer(deadline){
      stopTimer();
      const tick = ()=>{
        const ms = Math.max(0, deadline - (Date.now() + serverOffset));
        const s = Math.ceil(ms/1000); timeLeft.textContent = String(s);
        if (ms <= 0) stopTimer();
      };
      tick(); state.timerInt = setInterval(tick, 200);
    }
    function stopTimer(){ if(state.timerInt){ clearInterval(state.timerInt); state.timerInt=null; } }

    function renderResults(container, countsArr, total, correctIdx){
      if(!container) return; if(!countsArr){ container.innerHTML=''; return; }
      const labels = ['A','B','C','D']; const max = Math.max(1, ...countsArr);
      container.innerHTML = countsArr.map((n,i)=>{
        const pct = total? Math.round(n*100/total) : 0;
        const barW = Math.max(5, Math.round((n/max)*100));
        const strong = (i===Number(correctIdx)) ? 'font-weight:700;' : '';
        return `<div class="row" style="gap:8px; align-items:center">
          <div class="tag" style="min-width:2rem; ${strong}">${labels[i]}</div>
          <div style="flex:1; border:1px solid var(--edge); border-radius:999px; overflow:hidden">
            <div style="height:12px; width:${barW}%; background:#1f2a55"></div>
          </div>
          <div class="small" style="min-width:72px; text-align:right">${n} (${pct}%)</div>
        </div>`;
      }).join('');
    }

    // ===== Bank parse/stage + export =====
    function parseBank(text){
      text = (text || '').trim(); if (!text) return [];
      try{ const data = JSON.parse(text); const arr = Array.isArray(data)? data : [data]; return arr.map(normalizeItem).filter(Boolean); }
      catch(_){ /* CSV fallback */ }
      const lines = text.split('\n').map(l=>l.endsWith('\r')? l.slice(0,-1) : l).filter(Boolean);
      if (lines.length < 2) return [];
      const header = lines[0].split(',').map(h=>h.trim().toLowerCase()); const idx = k => header.indexOf(k);
      const out = [];
      for (let i=1;i<lines.length;i++){
        const cols = lines[i].split(',');
        const item = {
          prompt:  cols[idx('prompt')]?.trim(),
          A:       cols[idx('a')]?.trim(),
          B:       cols[idx('b')]?.trim(),
          C:       cols[idx('c')]?.trim(),
          D:       cols[idx('d')]?.trim(),
          correct: cols[idx('correct')]?.trim(),
          seconds: Number(cols[idx('seconds')] || 30),
          percent: Number(cols[idx('percent')] || NaN),
          explanation: cols[idx('explanation')]?.trim()
        };
        const norm = normalizeItem(item); if (norm) out.push(norm);
      }
      return out;
    }
    function normalizeItem(raw){
      if (!raw) return null;
      const prompt = raw.prompt || raw.question || '';
      let options = raw.options || [raw.A, raw.B, raw.C, raw.D];
      if (!Array.isArray(options) || options.length < 4) return null;
      options = options.slice(0, 4);

      let correctIndex = (typeof raw.correctIndex === 'number') ? raw.correctIndex : null;
      if (correctIndex == null && typeof raw.correct === 'string') {
        const map = { A:0, B:1, C:2, D:3 }; correctIndex = map[(raw.correct || '').toUpperCase()];
      }
      const seconds = Number(raw.seconds || 30);
      let percent = Number(raw.percent); if (!Number.isFinite(percent)) percent = undefined;
      const explanation = (raw.explanation && String(raw.explanation).trim()) || undefined;

      if (!(Number.isInteger(correctIndex) && correctIndex >= 0 && correctIndex <= 3)) return null;
      return { prompt, options, correctIndex, seconds, ...(percent!=null ? {percent}: {}), ...(explanation ? {explanation}: {}) };
    }

    importBankBtn.addEventListener('click', ()=>{
      const arr = parseBank(bankText.value);
      state.bank = arr; state.bankIndex = 0; state.progressAbs = 0;
      bankCount.textContent = String(arr.length);
      bankNext.textContent = String(arr.length ? 1 : 0);
      syncLadderToProgress();
      alert(arr.length ? `Loaded ${arr.length} questions` : 'No valid questions found');
    });

    stageNextBtn.addEventListener('click', ()=>{
      const i = state.bankIndex;
      if (!state.bank.length || i >= state.bank.length) { alert('Bank empty or finished'); return; }
      const item = state.bank[i];
      qPrompt.value = item.prompt;
      opt0.value = item.options[0] || '';
      opt1.value = item.options[1] || '';
      opt2.value = item.options[2] || '';
      opt3.value = item.options[3] || '';
      correctIndex.value = String(item.correctIndex || 0);
      answerWindow.value = String(item.seconds || 30);
      qExplanation.value = item.explanation || '';

      state.stagedIndex = i;
      state.stagedPercent = Number.isFinite(item.percent) ? item.percent : undefined;

      state.bankIndex++;
      bankNext.textContent = String(Math.min(state.bankIndex + 1, state.bank.length));
    });

    // Export all answers + players to CSV (host-side)
    exportBtn.addEventListener('click', async ()=>{
      const code = state.room;
      const [playersSnap, metaSnap] = await Promise.all([
        get(ref(db, `rooms/${code}/players`)),
        get(ref(db, `rooms/${code}/meta`)),
      ]);
      const players = playersSnap.val()||{};
      const qCount = (metaSnap.val()?.qIndex) || 0;

      // pull each qid answers
      const rows = [];
      for (let qid=1; qid<=qCount; qid++){
        const ansSnap = await get(ref(db, `rooms/${code}/answers/${qid}`));
        const answers = ansSnap.val()||{};
        for (const [uid, a] of Object.entries(answers)){
          rows.push({ qid, uid, name: players[uid]?.name || 'Player', index: a.index, at: a.at });
        }
      }
      const header = 'qid,uid,name,index,at\n';
      const body = rows.map(r=>[r.qid,r.uid,JSON.stringify(r.name),r.index,r.at].join(',')).join('\n');
      const blob = new Blob([header+body], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `room_${code}_results.csv`; a.click();
      URL.revokeObjectURL(url);
    });

  </script>
</body>
</html>
